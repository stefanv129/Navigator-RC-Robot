/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "GPIO.h"
#include "RCC.h"
#include "TIMER.h"
#include "I2C.h"
#include "USART.h"
#include "MOVEMENT.h"

#include <math.h>


#define ACCEL_SENS_2G 16384.0f
#define GYRO_SENS_500DPS 65.5f
#define START_PSW	129

typedef enum {
	NOT_TURNING = 0,
	TURNING_RIGHT = 1,
	TURNING_LEFT = 2,
} DirectionState_t;

DirectionState_t direction_state = NOT_TURNING;

typedef enum {
	STATE_IDLE,
	STATE_DRIVING,
	STATE_TURNING,
	STATE_STOPPED,
} RobotState_t;

RobotState_t current_state = STATE_IDLE;

GP_TIM_Handle_t TIM2_PWM;
AD_TIM_Handle_t TIM1_TMR;
I2C_Handle_t I2C1_RX;
USART_Handle_t USART1_TXRX;

int16_t X_POINT = 0; //current X
int16_t Y_POINT = 0; //current Y
float ANGLE = 270;
uint8_t INCREMENT = 0;
volatile uint16_t DRIVING_START_TIME = 0;  // global
volatile uint16_t DRIVING_ELAPSED_TIME = 0;  // global
volatile uint16_t TURNING_START_TIME = 0;  // global
volatile uint16_t TURNING_ELAPSED_TIME = 0;  // global
volatile uint8_t calc_angle_flag = 0;
volatile uint8_t send_coords_flag = 0;
volatile uint8_t wall_sensed = 0;
volatile uint8_t stop_flag = 0;

//start at origin

void init_random_seed(void);
uint16_t get_random_direction(void);
void Full_RCC_Config(void);
void Full_GPIO_Config(void);
void Full_GP_TIM_Config(void);
void Full_AD_TIM_Config(void);
void Full_I2C_Config(void);
void Full_USART_Config(void);
uint16_t get_elapsed_time(AD_TIM_RegDef_t *pTIMx, uint16_t start);

void init_random_seed(void) {
	srand(TIM1_TMR.pTIMx->CNT);  // Seed with x,y coords/angle
}

uint16_t get_random_direction(void) {
	return 150 + (rand() % 450);  // Between 50 - 200 ms lets say
	//what is maximum rand value?
}

uint16_t calc_rotation(uint32_t duration_ms, float angular_velocity_dps) {
	return (uint16_t)((duration_ms / 1000.0f) * angular_velocity_dps);  // degrees = time * speed
}

void ms_delay(uint32_t time_ms) {
	for(volatile uint32_t i = 0; i < time_ms * 1055; ++i) {
		__asm__("nop");
	}
}

uint16_t get_current_time(AD_TIM_RegDef_t *pTIMx)
{
	uint16_t time = pTIMx->CNT;
	return time;
}


uint16_t get_elapsed_time(AD_TIM_RegDef_t *pTIMx, uint16_t start)
{
	uint16_t now = pTIMx->CNT;
	uint16_t elapsed;

	if (now >= start) {
		elapsed = now - start;
	} else {
		elapsed = (0xFFFF - start) + now + 1; // handle overflow
	}
	return elapsed - 25;//error
}


uint8_t password = 0;
uint8_t coords_nr = 100;
uint8_t count = 0;

void send_coordinates()
{
	//	DRIVING_ELAPSED_TIME = get_elapsed_time(TIM1, DRIVING_START_TIME);//how long driving took place
	//	sprintf(msg2, "Drove for %u\r\n", DRIVING_ELAPSED_TIME);
	//	USART_SendData(&USART1_TXRX, (uint8_t*)msg2, strlen(msg2));

	//X_POINT = X_POINT + DRIVING_ELAPSED_TIME * speed * sinf(ANGLE * (M_PI / 180.0f);
	//X_POINT = Y_POINT + DRIVING_ELAPSED_TIME * speed * cosf(ANGLE * (M_PI / 180.0f);

	X_POINT = X_POINT + (DRIVING_ELAPSED_TIME /100) * sinf(ANGLE * (M_PI / 180.0f));
	Y_POINT = Y_POINT + (DRIVING_ELAPSED_TIME /100) * cosf(ANGLE * (M_PI / 180.0f));

	int16_t COORD_X = X_POINT + (int16_t)(7.0f * sinf(ANGLE * (M_PI / 180.0f)));
	int16_t COORD_Y = Y_POINT + (int16_t)(7.0f * cosf(ANGLE * (M_PI / 180.0f)));


	DRIVING_ELAPSED_TIME = 0;
	DRIVING_START_TIME = 0;

	//Build packet
	uint8_t data[5];
	data[0] = '!'; // Start byte

	data[1] = (uint8_t)((COORD_X >> 8) & 0xFF); // X high byte
	data[2] = (uint8_t)(COORD_X & 0xFF);        // X low byte

	data[3] = (uint8_t)((COORD_Y >> 8) & 0xFF); // Y high byte
	data[4] = (uint8_t)(COORD_Y & 0xFF);        // Y low byte

	// Send 5 bytes over USART
	USART_SendData(&USART1_TXRX, data, 5);

	count++;

	if(count >= coords_nr){
		stop_flag = 1;
	}

}




int main(void) {

	//while(1);

	Full_RCC_Config();
	Full_AD_TIM_Config();
	Full_GPIO_Config();
	Full_GP_TIM_Config();
	Full_USART_Config();
	Full_I2C_Config();
	init_random_seed();
	ms_delay(500);


	while (1)
	{

		if(stop_flag){
			stop_FWD(&TIM2_PWM);
			current_state = STATE_IDLE;
			GPIO_IRQInterruptConfig(EXTI4_IRQ, DISABLE);


			for(volatile int i = 0; i < 10; i++)
			{
				GPIO_Toggle_Pin(GPIOC, GPIO_PIN_NO_13);
				ms_delay(200);
			}
		}

		if(calc_angle_flag){
			//use ELAPSED TIME and angular_velocity to calc angle
			//calc_angle();
			calc_angle_flag = 0;
			DRIVING_START_TIME = get_current_time(TIM1);
			DRIVING_ELAPSED_TIME = 0;
		}

		if(current_state == STATE_DRIVING)
		{
			//float accel_g = raw_accel / 16384.0f;  // if FSR = ±2g
			//INCREMENT = accel_g  * 50 ms
			//			INCREMENT = 1;
			//			float angle_rad = ANGLE * (M_PI / 180.0f);
			//			X_POINT += (int16_t)(INCREMENT * sinf(angle_rad));
			//			Y_POINT += (int16_t)(INCREMENT * cosf(angle_rad));
			//every 50 ms
		}
		else if(current_state == STATE_TURNING)
		{
			//float gyro_dps = raw_gyro / 65.5f;  // if FSR = ±500°/s
			//angular_velocity = read_w_gyro(); => Z, last 2 bytes of the 6 read
		}
		else if(current_state == STATE_IDLE)
		{
			USART_ReceiveData(&USART1_TXRX, &password, 1);
			ms_delay(50);
			USART_ReceiveData(&USART1_TXRX, &coords_nr, 1);
			ms_delay(50);
			if(password == START_PSW)
			{
				//START CONDITION basically
				current_state = STATE_DRIVING;
				//char msg[32];
				drive_FWD(&TIM2_PWM);
//				sprintf(msg, "Navigation Started");
//				USART_SendData(&USART1_TXRX, (uint8_t*)msg, strlen(msg));
				//measure acceleration here??
				DRIVING_START_TIME = get_current_time(TIM1);
//				sprintf(msg, "StartedDrivingAt %u\r\n", DRIVING_START_TIME);
//				USART_SendData(&USART1_TXRX, (uint8_t*)msg, strlen(msg));
				GPIO_IRQInterruptConfig(EXTI4_IRQ, ENABLE);
			}
		}
		else if(current_state == STATE_STOPPED)
		{

		}

		ms_delay(50);

		//uint16_t current_time = get_current_time(TIM1);
		//	    char time_msg[32];
		//
		//	    // Add \r\n for proper line break
		//	    sprintf(time_msg, "TIM1 CNT: %u\r\n", current_time);
	}
	return 0;
}



void EXTI4_IRQHandler(void) //WALL SENSED
{
	//GPIO_IRQInterruptConfig(EXTI4_IRQ, DISABLE);

	if(!GPIO_Read_Pin(GPIOA, GPIO_PIN_NO_4)){
		GPIO_Write_Pin(GPIOC,GPIO_PIN_NO_13,DISABLE);
		wall_sensed = 1;
//		char msg2[32];
//		sprintf(msg2, "StoppedDrivingAt %u\r\n", get_current_time(TIM1));
//		USART_SendData(&USART1_TXRX, (uint8_t*)msg2, strlen(msg2));
		stop_FWD(&TIM2_PWM);//driving stops here
		DRIVING_ELAPSED_TIME = get_elapsed_time(TIM1, DRIVING_START_TIME);//how long driving took place
//		sprintf(msg2, "DroveFor %u\r\n", DRIVING_ELAPSED_TIME);
//		USART_SendData(&USART1_TXRX, (uint8_t*)msg2, strlen(msg2));

		send_coordinates();
		ms_delay(200);

		current_state = STATE_TURNING;
		calc_angle_flag = 0;
		TURNING_ELAPSED_TIME = 0;
		uint16_t turn_dir = get_random_direction();
//		sprintf(msg2, "RandomDir: %u\r\n", (uint16_t)turn_dir);
//		USART_SendData(&USART1_TXRX, (uint8_t*)msg2, strlen(msg2));

		if(!(turn_dir % 2))
		{
			direction_state = TURNING_RIGHT;
			turn_RGT(&TIM2_PWM);
		}
		else
		{
			direction_state = TURNING_LEFT;
			turn_LFT(&TIM2_PWM);
		}
		TURNING_START_TIME = get_current_time(TIM1);
//		sprintf(msg2, "StartedTurningAt %u\r\n", TURNING_START_TIME);
//		USART_SendData(&USART1_TXRX, (uint8_t*)msg2, strlen(msg2));
	}
	else{
		if(wall_sensed){
			wall_sensed = 0;
			//char msg3[32];
			stop_FWD(&TIM2_PWM);//turning stops here
//			sprintf(msg3, "StoppedTurningAt %u\r\n", get_current_time(TIM1));
//			USART_SendData(&USART1_TXRX, (uint8_t*)msg3, strlen(msg3));
			TURNING_ELAPSED_TIME = get_elapsed_time(TIM1,TURNING_START_TIME);
//			sprintf(msg3, "TurnedFor %u\r\n", TURNING_ELAPSED_TIME);
//			USART_SendData(&USART1_TXRX, (uint8_t*)msg3, strlen(msg3));

			//calc_angle();
			//calc angle using TURNING_ELAPSED_TIME & angular_velocity, some error is expected

			ms_delay(500);

			current_state = STATE_DRIVING;
			DRIVING_START_TIME = get_current_time(TIM1);
			drive_FWD(&TIM2_PWM);
//			sprintf(msg3, "StartedDrivingAt %u\r\n", DRIVING_START_TIME);
//			USART_SendData(&USART1_TXRX, (uint8_t*)msg3, strlen(msg3));
			GPIO_Write_Pin(GPIOC,GPIO_PIN_NO_13,ENABLE);
		}
	}
	GPIO_IRQHandling(GPIO_PIN_NO_4);
	//GPIO_IRQInterruptConfig(EXTI4_IRQ, ENABLE);

	//SHOULD ADD FLAGS FOR SAFETY => TURNING/DRIVING STARTED = 1

}

void Full_RCC_Config(void){
	RCC_Handle_t RCC_Handle;
	RCC_Handle.pRCC = RCC;
	RCC_Handle.RCC_Config.CLK_Source = HSI;
	RCC_Handle.RCC_Config.Prescalers.AHB_Presc = AHB_DIV1;//0x0
	RCC_Handle.RCC_Config.Prescalers.APB1_Presc = APB1_DIV2;//0x4
	RCC_Handle.RCC_Config.Prescalers.APB2_Presc = APB2_DIV2;//0x4
	RCC_Clock_Config(&RCC_Handle);
}

void Full_GPIO_Config(void){
	// Testing LED Config
	// GPIO Configuration for TESTPIN PC13 = LED
	GPIO_Handle_t GpioLED;
	GpioLED.pGPIOx = GPIOC;
	GpioLED.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GpioLED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GpioLED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioLED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioLED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// SENSOR CONFIG
	// GPIO Configuration for GpioSensor PA4 = GPIO INTERRUPT
	GPIO_Handle_t GpioSensor;
	GpioSensor.pGPIOx = GPIOA;
	GpioSensor.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_4;
	GpioSensor.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_RFT;
	GpioSensor.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_LOW;
	GpioSensor.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;


	// SLP CONTROL CONFIG
	// GPIO Configuration for GpioSensor PB15
	GPIO_Handle_t GpioSleep;
	GpioSleep.pGPIOx = GPIOB;
	GpioSleep.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
	GpioSleep.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GpioSleep.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioSleep.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioSleep.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// UART CONFIG
	// GPIO Configuration for UART_TX PA9 = UART_TX
	GPIO_Handle_t GpioTX;
	GpioTX.pGPIOx = GPIOA;
	GpioTX.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
	GpioTX.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;//AF07
	GpioTX.GPIO_PinConfig.GPIO_PinAltFunMode = 7;
	GpioTX.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioTX.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioTX.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for GpioSensor PA10 = UART_RX
	GPIO_Handle_t GpioRX;
	GpioRX.pGPIOx = GPIOA;
	GpioRX.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_10;
	GpioRX.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;//AF07
	GpioRX.GPIO_PinConfig.GPIO_PinAltFunMode = 7;
	GpioRX.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioRX.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH4 (PA3)
	GPIO_Handle_t GpioCH4;
	GpioCH4.pGPIOx = GPIOA;
	GpioCH4.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_3;
	GpioCH4.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH4.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH4.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH4.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH4.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH3 (PA2)
	GPIO_Handle_t GpioCH3;
	GpioCH3.pGPIOx = GPIOA;
	GpioCH3.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_2;
	GpioCH3.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH3.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH3.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH3.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH3.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH2 (PB3)
	GPIO_Handle_t GpioCH2;
	GpioCH2.pGPIOx = GPIOB;
	GpioCH2.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_3;
	GpioCH2.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH2.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH2.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH2.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH1 (PA0)
	GPIO_Handle_t GpioCH1;
	GpioCH1.pGPIOx = GPIOA;
	GpioCH1.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_0;
	GpioCH1.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH1.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH1.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH1.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for SDA (PB6)
	GPIO_Handle_t GpioSCL;
	GpioSCL.pGPIOx = GPIOB;
	GpioSCL.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GpioSCL.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioSCL.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioSCL.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioSCL.GPIO_PinConfig.GPIO_PinAltFunMode = 4;  // AF4 for I2C1_sCL
	GpioSCL.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for SCL (PB7)
	GPIO_Handle_t GpioSDA;
	GpioSDA.pGPIOx = GPIOB;
	GpioSDA.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GpioSDA.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioSDA.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioSDA.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioSDA.GPIO_PinConfig.GPIO_PinAltFunMode = 4;  // AF4 for I2C1_sDA
	GpioSDA.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// Initialize GPIO
	GPIO_Init(&GpioLED); //turns led on
	GPIO_Init(&GpioSensor);
	GPIO_Init(&GpioCH3);
	GPIO_Init(&GpioCH2);
	GPIO_Init(&GpioCH1);
	GPIO_Init(&GpioCH4);
	GPIO_Init(&GpioSCL);
	GPIO_Init(&GpioSDA);
	GPIO_Init(&GpioTX);
	GPIO_Init(&GpioRX);

	GPIO_Init(&GpioSleep);

	//GPIO_IRQInterruptConfig(EXTI15_10_IRQ, ENABLE);
}

void Full_GP_TIM_Config(void){

	// GP Timer Configuration
	TIM2_PWM.pTIMx = TIM2;
	TIM2_PWM.GP_TIM_Config.Prescaler = 4;
	TIM2_PWM.GP_TIM_Config.Period = 3200;

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH1].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH1].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH1].DutyCycle = 10;

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH2].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH2].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH2].DutyCycle = 10;

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH3].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH3].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH3].DutyCycle = 10;

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH4].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH4].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH4].DutyCycle = 10;

	// Initialize TIM2 + CHANNELS
	GP_TIM_PWM_INIT(&TIM2_PWM);  // Initialize with CH1 disabled
}

void Full_AD_TIM_Config(void){

	// AD Timer Configuration
	TIM1_TMR.pTIMx = TIM1;

	//TIM1_CDN.AD_TIM_Config.ClockDivision = 4;
	TIM1_TMR.AD_TIM_Config.Prescaler = PRESCALER_16K;
	AD_TIM_FreeRun_INIT(&TIM1_TMR);
}


void Full_I2C_Config(void){
	I2C1_RX.I2C_Config.I2C_AckControl = 1;
	I2C1_RX.I2C_Config.I2C_SCLSpeed = 100000;
	I2C_SM_INIT(&I2C1_RX);
}

void Full_USART_Config(void){

	USART1_TXRX.pUSARTx = USART1;
	USART1_TXRX.USART_Config.USART_Mode = USART_MODE_TXRX;
	USART1_TXRX.USART_Config.USART_Baud = USART_STD_BAUD_9600;
	USART1_TXRX.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
	USART1_TXRX.USART_Config.USART_NoOfStopBits	= USART_STOPBITS_1;
	USART1_TXRX.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
	//enable peripheral via cr1?

	USART_INIT(&USART1_TXRX);
	//USART1_TXRX.pUSARTx->CR1 |= (1 << 13);
}
