/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>
#include "GPIO.h"
#include "RCC.h"
#include "TIMER.h"
#include "I2C.h"
#include "MOVEMENT.h"

#include <math.h>


#define ACCEL_SENS_2G 16384.0f
#define GYRO_SENS_500DPS 65.5f


typedef enum {
	STATE_IDLE,
	STATE_DRIVING,
	STATE_TURNING,
} RobotState_t;

RobotState_t current_state = STATE_IDLE;

GP_TIM_Handle_t TIM2_PWM;
AD_TIM_Handle_t TIM1_CDN;
I2C_Handle_t I2C1_RX;

int16_t X_POINT = 0; //cuurent X
int16_t Y_POINT = 0; //cuurent Y
float ANGLE = 90;
uint8_t INCREMENT = 0;
uint32_t TURN_DURATION = 0;

//start at origin
//should be signed integers?

void init_random_seed(void);
uint32_t get_random_duration(void);
void Full_RCC_Config(void);
void Full_GPIO_Config(void);
void Full_GP_TIM_Config(void);
void Full_AD_TIM_Config(void);
void Full_I2C_Config(void);

void init_random_seed(void) {
	srand(129);  // Seed with timer count for variability
}

uint32_t get_random_duration(void) {
	return 50 + (rand() % 2000);  // Between 50 - 200 ms lets say
	//what is maximum rand value?
}

uint16_t calc_rotation(uint32_t duration_ms, float angular_velocity_dps) {
	return (uint16_t)((duration_ms / 1000.0f) * angular_velocity_dps);  // degrees = time * speed
}

void ms_delay(uint32_t time_in_ms)
{
	//16 mhz freq?
	//APB1_CLOCK_FREQ
	time_in_ms = time_in_ms / 1000; //=> seconds
	time_in_ms = (1 / APB1_CLOCK_FREQ) * time_in_ms;

	for(int i =0; i<time_in_ms; i++){}
}

int main(void) {

	Full_RCC_Config();
	Full_AD_TIM_Config();
	Full_GPIO_Config();
	Full_GP_TIM_Config();
	Full_I2C_Config();
	init_random_seed();


	//begin with drive FWD if start is initialized
	drive_FWD(&TIM2_PWM);

	//when wall is sensed
	while (1)
	{
		if(current_state == STATE_DRIVING)
		{
			//float accel_g = raw_accel / 16384.0f;  // if FSR = ±2g
			//INCREMENT = accel_g  * 10 ms
			//	X_POINT = X_POINT + INCREMENT * sin(ANGLE);
			//	Y_POINT = Y_POINT + INCREMENT * cos(ANGLE);
		}
		else if(current_state == STATE_TURNING)
		{
			//float gyro_dps = raw_gyro / 65.5f;  // if FSR = ±500°/s
			//angular_velocity = read_w_gyro(); => Z, last 2 bytes of the 6 read
			//ANGLE = (ANGLE + calc_rotation(10ms,w))%360;
		}
		else
		{

		}
		srand(X_POINT%Y_POINT*ANGLE);
		//10 ms delay lets say => update every 10 ms
		//timer duration becomes irrelevant this way
		//only state dictates
	}
	return 0;
}



void EXTI4_IRQHandler(void) //WALL SENSED
{
	//store coordinates +7cm (distance sensor measures 7 cm in front)

	//	int16_t COORD_X = X_POINT + 7 * sin(ANGLE * DEG_TO_RAD);
	//  int16_t COORD_Y = Y_POINT + 7 * cos(ANGLE * DEG_TO_RAD);
	// if we use 1cm as reference (maybe too much)

	//send coords via UART to ESP32 => only COORD_X and COORD_Y
	//they need to be parsed to be read
	//esp32 sends them to laptop

	current_state = STATE_TURNING;
	//if GPIOA4 is low wall was sensed
	if (!(GPIO_Read_Pin(GPIOA, GPIO_PIN_NO_4)))
	{
		GPIO_IRQHandling(GPIO_PIN_NO_4);  // Clear EXTI pending bit

		uint32_t turn_duration = get_random_duration();//seeding needed using coords?
		//duration should be in a given range
		if(!(turn_duration % 2))
		{
			turn_RGT(&TIM2_PWM);
		}
		else
		{
			turn_LFT(&TIM2_PWM);
		}

		AD_TIM_Start_Countdown(TIM1_CDN.pTIMx,turn_duration);
		//exits to while(1)
	}
	//GPIO_Toggle_Pin(GPIOC, GPIO_PIN_NO_13);
}


void TIM1_UP_TIM10_IRQHandler(void) //ROTATION TIME OVER
{
	GPIO_Toggle_Pin(GPIOC, GPIO_PIN_NO_13); //light signal

	while(GPIO_Read_Pin(GPIOA, GPIO_PIN_NO_4)){
		//angular_velocity = read_w_gyro();
		//ANGLE = ANGLE + calc_rotation(10ms,angular_velocity);
		//10 ms delay as well
	}
	//walls still sensed
	//turn until they are gone
	//bad in interrupt but it is a good failsafe if car is stuck

	current_state = STATE_DRIVING;
	drive_FWD(&TIM2_PWM);

	TIM1_CDN.pTIMx->SR &= ~TIM_SR_UIF;
}


void Full_RCC_Config(void){
	RCC_Handle_t RCC_Handle;
	RCC_Handle.pRCC = RCC;
	RCC_Handle.RCC_Config.CLK_Source = HSI;
	RCC_Handle.RCC_Config.Prescalers.AHB_Presc = AHB_DIV1;//0x0
	RCC_Handle.RCC_Config.Prescalers.APB1_Presc = APB1_DIV2;//0x4
	RCC_Handle.RCC_Config.Prescalers.APB2_Presc = APB2_DIV2;//0x4
	RCC_Clock_Config(&RCC_Handle);
}

void Full_GPIO_Config(void){
	// Testing LED Config
	// GPIO Configuration for TESTPIN PC13 = LED
	GPIO_Handle_t GpioLED;
	GpioLED.pGPIOx = GPIOC;
	GpioLED.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
	GpioLED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	GpioLED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioLED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioLED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// SENSOR CONFIG
	// GPIO Configuration for GpioSensor PA4 = GPIO INTERRUPT
	GPIO_Handle_t GpioSensor;
	GpioSensor.pGPIOx = GPIOA;
	GpioSensor.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_4;
	GpioSensor.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_FT;
	GpioSensor.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
	GpioSensor.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;



	// GPIO Configuration for TIM2 CH4 (PA3)
	GPIO_Handle_t GpioCH4;
	GpioCH4.pGPIOx = GPIOA;
	GpioCH4.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_3;
	GpioCH4.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH4.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH4.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH4.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH4.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH3 (PA2)
	GPIO_Handle_t GpioCH3;
	GpioCH3.pGPIOx = GPIOA;
	GpioCH3.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_2;
	GpioCH3.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH3.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH3.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH3.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH3.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH2 (PB3)
	GPIO_Handle_t GpioCH2;
	GpioCH2.pGPIOx = GPIOB;
	GpioCH2.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_3;
	GpioCH2.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH2.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH2.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH2.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH2.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for TIM2 CH1 (PA0)
	GPIO_Handle_t GpioCH1;
	GpioCH1.pGPIOx = GPIOA;
	GpioCH1.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_0;
	GpioCH1.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioCH1.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioCH1.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioCH1.GPIO_PinConfig.GPIO_PinAltFunMode = 1;  // AF1 for TIM2_PWM
	GpioCH1.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for SDA (PB6)
	GPIO_Handle_t GpioSCL;
	GpioSCL.pGPIOx = GPIOB;
	GpioSCL.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
	GpioSCL.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioSCL.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioSCL.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioSCL.GPIO_PinConfig.GPIO_PinAltFunMode = 4;  // AF4 for I2C1_sCL
	GpioSCL.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// GPIO Configuration for SCL (PB7)
	GPIO_Handle_t GpioSDA;
	GpioSDA.pGPIOx = GPIOB;
	GpioSDA.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
	GpioSDA.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	GpioSDA.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;  // Set higher speed for PWM
	GpioSDA.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	GpioSDA.GPIO_PinConfig.GPIO_PinAltFunMode = 4;  // AF4 for I2C1_sDA
	GpioSDA.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	// Initialize GPIO
	GPIO_Init(&GpioLED); //turns led on
	GPIO_Init(&GpioSensor);
	GPIO_Init(&GpioCH3);
	GPIO_Init(&GpioCH2);
	GPIO_Init(&GpioCH1);
	GPIO_Init(&GpioCH4);
	GPIO_Init(&GpioSCL);
	GPIO_Init(&GpioSDA);

	GPIO_IRQInterruptConfig(EXTI4_IRQ, ENABLE);
}

void Full_GP_TIM_Config(void){

	// GP Timer Configuration
	TIM2_PWM.pTIMx = TIM2;
	TIM2_PWM.GP_TIM_Config.Prescaler = 4;
	TIM2_PWM.GP_TIM_Config.Period = 100;

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH1].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH1].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH1].DutyCycle = DutyCycle_60;  // 80% Duty

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH2].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH2].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH2].DutyCycle = DutyCycle_60;  // 80% Duty

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH3].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH3].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH3].DutyCycle = DutyCycle_60;  // 80% Duty

	TIM2_PWM.GP_TIM_Config.CH_Setup[CH4].CH_Enabled = ENABLE;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH4].CH_Mode = PWM1;
	TIM2_PWM.GP_TIM_Config.CH_Setup[CH4].DutyCycle = DutyCycle_60;  // 80% Duty

	// Initialize TIM2 + CHANNELS
	GP_TIM_PWM_INIT(&TIM2_PWM);  // Initialize with CH1 disabled
}

void Full_AD_TIM_Config(void){

	// AD Timer Configuration
	TIM1_CDN.pTIMx = TIM1;

	//TIM1_CDN.AD_TIM_Config.ClockDivision = 4;
	TIM1_CDN.AD_TIM_Config.Prescaler = PRESCALER_16K;
	AD_TIM_CDN_INIT(&TIM1_CDN);
}

void Full_I2C_Config(void){
	I2C1_RX.pI2Cx = I2C1;
	I2C1_RX.I2C_Config.I2C_AckControl = 1;
	I2C1_RX.I2C_Config.I2C_SCLSpeed = 100000;
	I2C_SM_INIT(&I2C1_RX);
}
